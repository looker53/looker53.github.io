{"posts":[{"title":"TOML 配置文件简明教程","content":"今天我们一起来学习toml这种简洁的配置文件格式吧。 TOML是在 2013 年发布的配置文件格式。距今虽然有8年历史了，但是之前一直没有在大项目中见过的。我是前段时间在看python的pep规范，无意中看到了这种配置文件格式，稍微了解了一下，才发现现在有很多新的明星项目都喜欢用它来做配置文件。 1、有rust语言的包管理工具cargo； 2、类似于docker的容器工具containerd； 3、go语言很多项目都喜欢用。比如静态网站生成工具Hugo、数据库InfluxDB、GitLab CI。 4、python项目也开始接纳。包管理工具 pip、pipenv和Poetry都是用的TOML,[1]现在连官方的metadata管理也开始支持toml。 1. 一个小例子 为什么新项目这么喜欢 TOML 呢？ 让我们先来看一个TOML的小例子吧，看完了说不定你就知道了。 [project] name = &quot;spam&quot; version = &quot;2020.0.0&quot; description = &quot;Lovely Spam! Wonderful Spam!&quot; readme = &quot;README.rst&quot; requires-python = &quot;&gt;=3.8&quot; license = {file = &quot;LICENSE.txt&quot;} keywords = [&quot;egg&quot;, &quot;bacon&quot;, &quot;sausage&quot;] 有没有感觉很熟悉呢？它和ini格式的配置文件几乎一模一样。要知道互联网发展到今天，大多数有影响力的项目都是采用ini这种配置文件格式，如果你之前有接触过ini，切换到toml几乎是0成本。 那为什么不直接用ini呢？因为ini格式支持的数据类型非常少，配置项的值都会被默认当成字符串，如果想表示数字、数组，还需要自己进行额外的解析。 但是在TOML中，数据类型非常丰富： 字符串 注释 数字 布尔值 数组 哈希表 甚至连时间格式都支持 2. 字符串 字符串我们当然不会陌生，但是如果你是从ini格式转过来的，一定要注意字符串值要加引号。 键默认会当成字符串处理，可以加也可以不加。 加引号的键叫引号键（Quoted Key）,不加引号的键叫裸键（Bare Key)。 TOML 格式非常灵活，对于灵活的语言，最好的方式是给自己设置规范和纪律，一直用好一种用法，不然很容易学废。官方推荐我们尽量用裸键，当裸键不能正确表达意思的时候，再用引号键。 name = &quot;spam&quot; #OK name_1 = spam #错误 &quot;name_2&quot; = &quot;spam&quot; #OK 裸键只能包含 ASCII 字母，ASCII 数字，下划线和短横线（A-Za-z0-9_-），引号键则可以支持特殊字符，甚至是空格。当键中包含特殊字符的时候，使用引号键。 'name@! erf:' = 'spam' # OK name@! erf: = 'spam' # 错误 当字符串为多行字符串时使用三引号，会自动换行： name = &quot;&quot;&quot; this is a new line command&quot;&quot;&quot; 得到的结果是： this is a new line command 如果不想自动换行，只是想增强可读性，可以使用折行符号\\： name = &quot;&quot;&quot; this is a \\ new line \\ command&quot;&quot;&quot; 得到结果是不换行的： this is a new line command 3. 数字 如果你都会编程了，数字应该会知道怎么表示。 age1 = 18 age2 = -2 age3 = +16 age4 = 11.2 toml除了支持10进制表示，还支持二进制（0b）、八进制（0o）、十六进制（0x） age1 = 0b11 age2 = 0o12 age3 = 0xb 上面的解析结果为： { 'age1': 3, 'age2': 10, 'age3': 11 } 4. 布尔 bool1 = true bool2 = false 5. 时间 时间类型是toml的一大特色，因为绝大多数的配置文件格式都是不支持时间类型的。toml 遵循的是 RFC 3339 时间格式，只要照着格式写，解析出来会自动转成编程语言的时间类型。 ts = 2021-01-06 07:30:00 ts1 = 2021-01-06 07:30:00.1234 time1 = 07:30:00 得到的结果： { 'ts': datetime.datetime(2021, 1, 6, 7, 30), 'ts1': datetime.datetime(2021, 1, 6, 7, 30, 0, 123000), 'time1': datetime.time(7, 30) } 6. 数组 数组可以是同类型数据，可以换行，也可以嵌套，和python当中列表简直一模一样。但是要注意，尽量保持元素是同类型的数据。 users = [ ['iswy', '男'], ['you', '女'], ] 得到结果： { 'users': [ ['iswy', '男'], ['you', '女'] ] } 7. 哈希表 表有点类似于python中的字典： user = {name='iswy', gender='男'} 得到的结果： { 'user': { 'gender': '男', 'name': 'iswy' } } 这种写在key后面的表叫内联表。还有一种用法，类似于ini格式中的section,用于分组管理，暂且把它叫做外联表。比如上面的例子，可以换一种形式，得到的结果是完全一样的。 [user] gender = '男' name = 'iswy' 表支持嵌套，子表可以缩进也可以不缩进： [user] cat = ['admin', 'normal'] [user.student] name='iswy' age=19 [user.teacher] name='you' age=32 如果你觉得这种风格你不喜欢，也可以换成下面的风格： [user] cat = ['admin', 'normal'] # student student.name='iswy' student.age=19 # teacher teacher.name='you' teacher.age=328 一定要注意，当键包含. 号时，一定要加引号： site.'x.com' = 'http://x.com' 我个人更倾向于子表嵌套的风格，因为这样的表述看起来更加简洁。 表和数组的配套使用 最后我们要考虑的问题是当有多个用户需要配置，我们要使用表数组进行分组呢？ [[user]] [user.student] name='iswy' age=19 [user.teacher] name='you' age=328 [[user]] [user.student] name='iswy2' age=192 [user.teacher] name='you2' age=3282 得到的结果： { 'user': [ { 'student': {'age': 19, 'name': 'iswy'}, 'teacher': {'age': 328, 'name': 'you'} }, { 'student': {'age': 192, 'name': 'iswy2'}, 'teacher': {'age': 3282, 'name': 'you2'} } ] } https://github.com/toml-lang/toml/wiki#projects-using-toml ↩︎ ","link":"https://looker53.github.io/post/toml-pei-zhi-wen-jian-jian-ming-jiao-cheng/"},{"title":"配置文件，首选 YAML 和 TOML","content":"1. 配置文件是什么？ 配置文件是用于配置计算机程序的参数和初始化设置的文件。如果没有这些配置，程序可能无法执行。 比如现在你要开发一款 app, 当部署这款 app 时，你需要配置它的 host 地址、数据库地址、数据库名称，这些都可以作为配置项写入配置文件。当项目上线，需要换一个环境运行时，只需要修改配置文件，不需要去代码当中到处查找。 配置文件通常是 key/value 的形式存在，任何支持解析 key/value 形式的文件都是可以作为配置文件的。 现在主流的配置文件格式非常多，比如： Linux 系统中的 .bashrc YAML TOML JSON XML INI 这些都是常用的配置文件格式。接下来，我们来看看用得最多的几种配置文件怎么编写，又是如何通过 python 语言解析的。 2. yaml # default host: &quot;http://www.iswy.com&quot; # 数据库 db: host: &quot;http://www.iswydb.com&quot; port: 3306 name: &quot;py&quot; # 账号 users: - name: &quot;iswy&quot; password: &quot;123456&quot; - name: &quot;iswy_wang&quot; password: &quot;666666&quot; YAML 是目前最推荐的配置文件格式。优秀的配置文件标准它几乎都有： 容易阅读和修改，支持注释。 支持丰富的数据类型。 不同格式的明确表达。 yaml 使用时需要注意： yaml 强制缩进。虽然不规定具体缩进几个空格，但是同一级的内容要保持相同的缩进。 冒号后面一定要加空格， 否则无法解析。 python 解析 yaml 可以使用 pyyaml 库，操作和标准的文件操作非常类似: import yaml with open('api.yml', encoding='utf-8') as f: data = yaml.load(f, Loader=yaml.SafeLoader) 得到的 data 就是解析后的数据，在 python 当中，它是一个嵌套的字典： { 'db': { 'host': 'http://www.iswydb.com', 'name': 'py', 'port': 3306 }, 'host': 'http://www.iswy.com', 'users': [ {'name': 'iswy', 'password': '123456'}, {'name': 'iswy_a', 'password': '666666'} ] } 想获取某一项配置，再通过字典的操作获取： db_host = data['db']['host'] 3. ini [default] host=http://www.iswy.com [db] host=&quot;http://www.iswydb.com&quot; port=3306 name=&quot;py&quot; ini 格式是用得非常多的配置文件格式，有大量的项目都使用 ini 编写配置文件，它比较适合配置项的数据类型只是简单的字符串、数字的情况，如果涉及数组和 key/value 的嵌套，会比较吃力。 ini 格式有几个概念需要了解。用 [] 的叫做 section, 用来对配置项进行分组， 下面的 port 和 name 叫做 option。 如果想获取某一个 option，必须先要获取 section。 通过 python解析 ini： from configparser import ConfigParser parser = ConfigParser() parser.read(&quot;api.ini&quot;, encoding=&quot;utf-8&quot;) host = parser.get(&quot;default&quot;, &quot;host&quot;) db_host = parser.get(&quot;db&quot;, &quot;host&quot;) ini 配置格式有几个注意点： section 无法嵌套， 嵌套后的效果和没有嵌套是一样的。 [default] [db] host=http://www.iswydb.com 获取这个 host 的方式不会发生任何变化，default 并不是 db 的父级。 字符串的表示不要加引号，否则引号也会被解析出来。 [db] host = &quot;http://www.iswydb.com&quot; host2 = http://www.iswydb.com 得到的结果： &quot;http://www.iswydb.com&quot; http://www.iswydb.com = 可以用空格，也可以不用。 4. json { &quot;db&quot;: { &quot;host&quot;: &quot;http://www.db.com&quot;, &quot;port&quot;: 3306 }, &quot;host&quot;: &quot;http://www.iswy.com&quot; } json 在配置文件中的使用频率是上面提到的格式中最低的，原因有几个： 不支持注释， 花括号太多，影响可读性。 通过 python 解析 json 文件： import json with open('api.json', encoding='utf-8') as f: data = json.loads(f.read()) 5. toml host = 'http://www.iswy.com' # 数据库 [db] host = &quot;http://www.iswydb.com&quot; port = 3306 name = &quot;py&quot; # 账号 users = [ {name = 'iswy', password = '123456'}, {name = 'iswy', password = '666666'} ] TOML 结合了 ini 和 yaml 的优点： TOML 的写法和 ini 几乎一致，切换成本为 0 ； 支持所有的 YAML 数据类型，甚至支持时间格式； 支持像 ini 的 section 分组，只是在 TOML 中，它叫做 table; 解析像 YAML 那样简单。 在 python 中解析 TOML 先安装: pip install toml 操作和普通文件的方式非常相似： import toml with open('api.toml', encoding='utf-8') as f: data = toml.loads(f.read()) TOML 的写法非常灵活，后面再出教程。 6. 什么样的数据适合放在配置文件里 配置文件的作用主要是给即将运行的程序提供初始值，凡是在环境发生改变时需要修改的选项就可以设置成配置项。比如上面的域名 host 和数据库设置。 当需要把程序部署到另外的环境，域名和数据库都有可能发生变化，此时可以设置成配置项。 什么样的数据不适合放在配置文件呢？ 每次运行程序都需要检查的，最好不要放在配置文件中，而是通过编程语言进行设置，比如某个依赖文件的路径。 7. 什么要的配置文件格式是好格式 容易阅读和修改、最好支持注释。 所以 json 不是一种好的格式。 易于解析，支持多数据类型。 INI 和 xml 不合适。 不同格式用不同的表达。 YAML 和 TOML 做得非常好。 用配置文件，选 YAML 和 TOML。 参考文献 https://jhall.io/posts/best-config-file-formats/ ","link":"https://looker53.github.io/post/pei-zhi-wen-jian-shou-xuan-yaml-he-toml/"},{"title":"python单元测试框架 pytest 入门","content":"1、引言 我有一个朋友是做Python自动化测试的。前几天他告诉我去参加一个大厂面试被刷了。 我问他是有没有总结被刷下来的原因。他说面试官问了一些 pytest 单元测试框架相关的知识，包括什么插件系统和用力筛选。但是他所在的公司用的技术是基于 unittest 的,没有用过 pytest。 我跟他说你可以和技术面试官说明，在实际过程当中你没有使用过 pytest，但是你可以后面再学。这哥们说：我就是这样跟面试官说的，但是面试官告诉我 pytest 现在已经是行业里面的主流，还在坚持用 unittest 说明我的技术已经过时了，没有跟上现在测试领域的发展。 实际上他在面试之前已经了解过 pytest 的一些基础用法，但是网上的一些资料，都是停留在用法和一些知识点的讲解，没有深入到 pytest 内部运行和一些高级特性。所以被问到的时候，自己临时抱佛脚的一些知识都没有用上。 后面我给这位朋友补习了一些关于Python的高级特性。现在我连同基础部分的内容一起贴出来，希望对Python自动化测试的一些朋友有所帮助。 2、为什么用单元测试框架？ 首先我要说明一下什么是单元测试框架? unittest 和 pytest 都是单元测试框架。单元测试指的是在编程过程当中形成的对函数或者是类下面的方法进行测试的一个过程。 在不使用任何框架的前提下，其实也是可以进行单元测试的。比如我们可以通过 if 判断 、异常处理或者是其他的流程控制来表示测试是否通过。 def add(a, b): return a + b def test_add(): ret = add(3, 4) if ret == 7: print(&quot;add 函数的测试通过&quot;) else: print(&quot;add 函数的测试失败&quot;) 如果要运行这个用例，需要手工调用 test_add 这个函数： test_add() 接下来，使用 python 运行这个文件，就能得到测试结果： python test_add.py 虽然说上面我们通过 if 判断，对一个函数进行了测试，而且得到了测试结果，但是流程是比较复杂的： 首先我们需要人工去判断结果， 第2我们需要通过 Python去运行模块。 第3，我们还需要显性的去调用 test_add 这个函数。 这还只是在我们只测试了一个函数的情况下，当需要测试的函数或者类越来越多的时候，这个过程会越来越复杂。 而使用单元测试框架，可以极大的简化我们对单元测试的过程，使用单元测试框架以后，框架会帮我们自动去收集用例、运行用例、生成报告。 3、pytest 的基础使用 上面的测试代码使用 pytest 编写，可以这样写。 def add(a, b): return a + b def test_add(): assert 7 == add(3,4) 写完测试用例以后，我们只需要在目录下输入pytest 指令，就可以自动运行用例，而且呢结果会直接显示在命令行的下方。 上面讲的是单元测试过程，也就是说对某个函数或者是类下面的方法进行测试，有的人可能会不理解。在实际工作过程当中很少进行单元测试啊，测试人员做的更多的是接口测试，UI测试，pytest 怎么用呢？ 实际上不管是接口测试还是UI测试，都是可以使用 pytest。当你进行接口测试的时候，你只需要把访问接口的过程封装成一个Python函数。 def visit_api(): print(&quot;访问接口,得到结果...&quot;) return response def test_api(): assert expected_response == visit_api() 当你进行 web测试的时候，你只需要操作浏览器的过程封装成一个函数？ def browser_method(): print(&quot;点点点&quot;) return ui_response def test_web(): assert expected_response == browser_method() 在这种情况下。接口访问和web操作都是以函数形式存在的，我们直接去测试这个 Python 函数，也是一个单元测试的过程。 因为 pytest 是一个第三方的框架，所以我们先要安装。安装方式非常简单，只需要通过 pip 这个包管理工具安装就可以了。 pip install -U pytest 安装完成以后，我们可以向使用上面的那个例子一样： 第1步：定义一个测试函数，这个测试函数通常会调用被测函数。 第2步：使用assert断言，assert 后面可以跟任意的 Python 条件表达式。 assert 4 &lt; 5 assert &quot;yuze&quot; in &quot;yuze wang&quot; assert isinstance(6, int) 测试用例函数有 2 个注意事项： 函数名称以test_开头； 保存测试用例的文件以test_*.py 的形式或者 *_test.py 的形式。 例行用了以后呢，在命令行当中会显示4个部分的内容: 第1个部分，测试用例和通过的结果， 第2个部分，失败用例回溯信息， 第3个部分，输出捕获信息， 第4个部分，总结信息。 在拍test当中通过的测试用例，不会有特别详细的结果，但是这是失败的测试用例默认会有非常详细的结果，而且会帮你捕获错误原因。 4、测试夹具（Fixture）是什么？ 在测试过程当中，有时你需要提前给你的测试用例去准备一个运行环境。这个测试环境通常来说被称为测试夹具（Fixture），又被称为固定装置、测试固件等。 当你要测试一个电器的时候，你需要提供不同的输入电压电流的环境， 当你测试一台电脑网络的时候，必须要提供网络环境， 当你要测试一个手机游戏能否被安装时，你需要提供一台手机环境， 当你要测试一个软件能否登录的时候，你需要准备用户名和密码这样的用户环境， 当你要测试一个数据库能否操作的时候，需要提供数据库的连接环境。 现在我们来举一个夹具的例子，我们需要测试一个注册的函数。这个注册函数提供两个参数，第1个参数是手机号，第2个参数是密码。注册函数的逻辑就是对手机号码和密码进行校验，如果通过校验表示注册成功，如果不通过表示注册失败。 def is_mobile(number: str): if re.search(r&quot;^1[3-9][0-9]{9}$&quot;, number): return True return False def register(mobile, password): if is_mobile(mobile) and len(password) &gt;= 6: return &quot;success&quot; return &quot;fail&quot; def test_register(): assert &quot;success&quot; == register(&quot;13177778888&quot;, &quot;123456&quot;) 这个测试用例并没有什么问题，但是它存在优化的空间。一个优化的空间是每个手机号码都是我们手工生成的，当需要编写多组数据测试时，会有一点费时间。现在我们可以编写一个函数，自动生成一个手机号码，当我有多组数据需要测试的时候，我只需要重复调用生成手机号码的函数，就可以获取测试数据。这个生成手机号码的函数呢，就是一个夹具。 def gen_a_mobile(): &quot;&quot;&quot;随机生成 13 开头的手机号码。&quot;&quot;&quot; random_num = &quot;&quot;.join([str(random.randint(1,9)) for i in range(9)]) return &quot;&quot;.join([&quot;13&quot;, random_num]) pytest 提供了一种叫做依赖注入的机制，当一个函数被声明为夹具的时候，可以在测试函数中传入这个夹具的名称，pytest会自动调用它。 import random import pytest @pytest.fixture def gen_a_mobile(): &quot;&quot;&quot;随机生成 13 开头的手机号码。&quot;&quot;&quot; random_num = &quot;&quot;.join([str(random.randint(1,9)) for i in range(9)]) return &quot;&quot;.join([&quot;13&quot;, random_num]) def test_register(gen_a_mobile): assert &quot;success&quot; == register(gen_a_mobile, &quot;123456&quot;) pytest 当中的夹具系统非常非常的灵活，后面如果有时间的我专门写文章跟大家讲解夹具系统。 5、数据驱动和参数化 现在我们编写的函数和测试用例是1对1的关系，也就是说，当你想测试某个功能场景的时候，你必须要去编写一个对应的测试函数。当测试的场景越来越多，测试数据越来越复杂的情况下，需要编写更多的测心率函数，而这些函数的逻辑基本上是重复的。 在 pytest 当中可以使用参数化这种测试手段，简化编写用例函数的过程。我们并不需要为每一组测试数据单独去编写一个测试函数，而是采取多种数据共用一个函数的方式。如果测试操作几乎一致，可以重复使用这一个函数进行测试。 import pytest cases = [ (1, 2, 3), (&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;), (1, &quot;world&quot;, &quot;1world&quot;) ] @pytest.mark.parametrize(&quot;a,b,expected&quot;, cases) def test_add(a, b, expected): assert expected == add(a, b) 在这个例子当中，cases这个变量存储了三组测试用例的数据，每一组测试数据用一个元组表示，元组的第1个元素代表a，第2个元素代表B，第3个元素代表预期结果。 @pytest.mark.parametrize(&quot;a,b,expected&quot;, cases) 这一行代码的意思是说，每一次从cases变量当中取出一组测试数据。分别用a、b 、expected 三个变量接收，然后我们把这三个变量名作为函数的参数传递到 test_add 当中，就实现了参数化的过程。 当使用这一种参数化的手段进行测试的时候，测试数据和测试函数是多对一的关系，对于多组测试数据，我们只需要去编写一个测试函数，极大的提升了代码编写效率。 6、测试报告和插件 最后我们来说一下测试报告。pytest 当中的测试报告，通常是以插件的形式生成的，如果你想生成一个html格式的测试报告，可以先安装 pytest-html 这个插件。 pip install pytest-html 接下来你需要在运行用例的时候，在 pytest 命令后面加上 --html=&lt;测试报告名称&gt;.html pytest --html=report.html 当运行完用例以后，你可以在当前目录下找到一个 report.html 的文件，打开就可以查看测试报告了。 pytest 之所以成为主流，有很多的原因，其中最重要的一个原因是因为其强大的插件系统。任何一个程序员，只要遵循一些简单的规范，就可以轻易的编写插件。后面我们再跟大家深入去研究 pytest 当中的夹具系统，插件系统和钩子函数这些特性。 ","link":"https://looker53.github.io/post/pytest-gettting-started/"}]}