{"posts":[{"title":"优化自动化测试流程，使用 flask 开发一个 toy jenkins工具","content":"1、自动化 某一天你入职了一家高大上的科技公司，开心的做着软件测试的工作，每天点点点，下班就走，晚上陪女朋友玩王者，生活很惬意。 但是美好时光一般不长，这种生活很快被女主管打破。为了提升公司测试效率，公司决定引入自动化流程，你在网上搜了一套技术方案 python + selenium，迅速写了一套自动化测试的脚本。 from selenium import webdriver def test_selenium(): driver = webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) ... driver.quit() ... 编写脚本的日子很累，你需要每天加班，而且没有加班工资。 虽然如此，你也没有太多怨言，因为你能明显感觉到自己一点点掌握了自动化测试的流程，正在踏入职业发展的新阶段。这套脚本很快用于公司的主流程测试，也会在回归测试中使用。 因为大量的重复劳动都可以用这套自动化测试脚本代替，于是你又有时间陪女朋友了，上班也可以偶尔划水了，也可以时不时瞄一瞄自己的基金有没有涨。 当然，美好时光一般不长。在一次大改版中，前端页面发生了大量变化，你的自动化测试代码因为没有做抽象封装，基本已经不能用了。 又可以加班了，生活又可以充实起来了。你动用了一些像 PageObject 的模式对代码进行了重新设计，也加入了关键字驱动，尽量让测试逻辑变成可配置的。 设计完成以后，当前端页面变化时，只需要重点维护关键字表格。 你又为公司做了一些贡献，你已经完全胜任自动化测试的工作，甚至能够带一两个小弟。他们时不时找你问一些问题，但是对于自动化的维护工作还是要靠你自己，当你请假时，这些工作只能停滞。于是公司希望你做一些改进，让功能测试人员也可以运行这些自动化测试。 2、开始测试平台 你看到网上有很多人提到测试平台，想着自己也可以做一个可视化平台，这样功能测试人员也可以通过在界面上进行简单的设置，就可以使用底层的自动化代码了。很快 flask 出现在你的视线中，你做的第一个功能就是实现类似于 jenkins 的构建功能。 首先，你搭建了一个 flask 服务，服务启动后，你能顺利访问 5000 端口。 from flask import Flask app = Flask(__name__) app.run(port=5000) 然后，你配置了一个 url 地址，当访问这个 url 地址时，服务会调用一个函数，这个 url 和函数的绑定关系就是路由。函数的返回值可以是普通字符串，可以是 json 数据，也可以是 html 页面。 @app.route('/') def index(): &quot;show all projects in workspace dir&quot; workspace = pathlib.Path(app.root_path) / 'workspace' projects = [project.name for project in workspace.iterdir()] return render_template('index.html', projects=projects) 上面的代码就是模仿 jenkins， 把自动化测试的脚本放在项目的 workspace 目录下，当访问 / 根路径时，index 函数就会被调用。index 函数的作用就是列举 workspace 目录下的所有项目名，通过 return 展示在前端界面。具体的前端代码如下： &lt;h2&gt;展示所有的项目&lt;/h2&gt; {% for p in projects %} &lt;div&gt; {{ p }} &lt;a href=&quot;/build?project={{p}}&quot;&gt;构建&lt;/a&gt; &lt;/div&gt; {% endfor %} 在页面上点击构建，程序会跳转到 flask 设置好的 /build 这个 url 中，这个路由负责运行自动化测试的代码，他会接收用户传过来的 project 参数，找到在 workspace 目录下的项目，再执行自动化测试指令（这里统一用 pytest 指令）。 @app.route(&quot;/build&quot;, methods=['get', 'post']) def build(): project_name = request.args.get('project') pytest.main([f'workspace/{project_name}']) return &quot;build success&quot; 到目前为止，完整的流程是这样的：首先，在平台首页会展示所有可以构建的项目，这些项目其实就是把 workspace 子目录当中的目录名列举出来；然后，点击项目旁边的构建按钮，跳转到 /build，根据项目名称执行自动化指令，等待自动化任务执行完成，返回 build success。 3、优化 你基本上已经实现了功能，现在功能测试人员可以通过你搭建的简易平台执行自动化命令。但是这个平台还存在一些问题：第一、没有收集到构建信息，无法查看测试之后的结果；第二、用户必须等待自行测试脚本执行完成，才能返回前端具体的结果，如果自动化测试的执行时间很长，用户会一直停在这个页面，无法做其他事情。 你想到了并发编程，创建一个子进程单独去运行自动化测试脚本，因为子进程可以和主进程独立，所以不需要等待子进程执行完成，主进程就可以立即给前端返回结果。于是你重新编写了 build 函数： @app.route(&quot;/build&quot;) def build(): id = uuid.uuid4().hex project_name = request.args.get('project') with open(id, mode='w', encoding='utf-8') as f: subprocess.Popen( ['pytest', f'workspace/{project_name}'], stdout=f ) return redirect(f'/build-history/{id}') 1、首先，通过 uuid 生成一个 id 号来表示这一次构建任务，之后可以通过这个 id 号查看此次构建的记录； 2、通过 subprocess 创建子进程运行自动化任务，把输出结果保存到文件当中，文件名就是生成的 id 号，之后想查看构建的结果时，只需要读取这个文件当中的内容； 3、只要子进程创建成功，马上通过 redirect 重定向到查看结果的 url， 此时并不需要等到子进程执行完就可以查看构建结果。 查看构建结果只需要通过 id 读取文件中的内容返回。 @app.route(&quot;/build-history/&lt;id&gt;&quot;) def build_history(id): with open(id, encoding='utf-8') as f: data = f.read() return data 4、生成器 上面读取文件的代码有点问题。当构建重定向到 /build-histrory 后，此时自动化测试脚本才刚刚执行，读取文件中的内容是空的。只有当测试脚本运行，产生越来越多的运行记录，文件中才会出现更多的内容，你必须手动刷新页面才能获取这些新内容。 当自动化任务执行时间很长的时候，你需要不停的刷新 /build-history 页面才能获取最新的构建信息。直到子进程结束，不再有新的内容被写入文件。 为了动态获取文件数据，你使用了生成器惰性获取数据，在 /build-history 的页面加载过程中，只要运行自动化任务的子进程还在运行，就不停的读取文件内容，将它们动态的返回给前端页面。 为了判断子进程的状态，在 /build 的时候，把子进程的 pid 传给 /build-history。 @app.route(&quot;/build&quot;, methods=['get', 'post']) def build(): id = uuid.uuid4().hex project_name = request.args.get('project') with open(id, mode='w', encoding='utf-8') as f: proc = subprocess.Popen( ['pytest', f'workspace/{project_name}'], stdout=f ) return redirect(f'/build-history/{id}?pid={proc.pid}') 在查看结果时，先编写一个生成器 stream, 每次读取文件中 100 长度的数据，直到进程运行结束。除了通过构建后的重定向，你也可以手动输入 id，查看历史构建记录。此时只需传 id, 不需要传进程名，直接读取文件中的数据。就算文件特别大，也可以通过批量加载，不至于因为同时读取大量数据给服务器造成压力。 import psutil @app.route(&quot;/build-history/&lt;id&gt;&quot;) def build_history(id): pid = request.args.get('pid', None) def stream(): f = open(id, encoding='utf-8') if not pid: while True: data = f.read(100) if not data: break yield data else: try: proc = psutil.Process(pid=int(pid)) except: return 'no such pid' else: while proc.is_running(): data = f.read(100) yield data return Response(stream()) 最后效果： 5、总结 一般来说，做自动化测试只需要做到第一步，有脚本可以执行，就可以代替重复劳动。做测试平台只是让脚本变得更加好用。 但是有很多的测试平台让自动化运行起来更加复杂，要配置很多很多参数才能跑一个完整的测试用例，这似乎有点折本求末，也是很多人都在做的事情。 本文通过 flask 程序实现了一个最简单的 toy jenkins，辅助理解像 jenkins 这样的工具如何执行任务。其实像简单的构建任务，做起来也有很多问题需要解决，这些只有在遇到具体业务的时候我们才会去思考。 希望我们做的工具都是实用的，好用的。 ","link":"https://yuz.one/you-hua-zi-dong-hua-ce-shi-liu-cheng-shi-yong-flask-kai-fa-yi-ge-toy-jenkins-gong-ju/"},{"title":"「明天再学」微信公众号开通了","content":"可以扫旁边的二维码关注。 ","link":"https://yuz.one/du-qian-bi-kan/"},{"title":"使用 CSS 选择器，定位网页元素","content":" css选择器在 web 领域应用非常普遍，不管是前端工程师还是 ui 自动化测试，使用 css 选择器都能精准快速定位到自己想要的元素。css 选择器的内容不是很多，稍微花一点时间就可以直接上手，在应用中就能逐渐掌握，当遇到一个表达式不是很熟练的时候，可以再回来查一下这篇文章。 先来看一下怎么使用 css 选择器。写一个简单的登录界面 HTML ： &lt;div class=&quot;container&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;登录&lt;/h2&gt; &lt;form id=&quot;loginForm&quot; action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; 使用 chrome 浏览器打开这个页面，按 F12 进入开发者调试工具，在工具界面按 ctrl + f 就可以输入 css 选择器表达式了。 在输入框中输入 .container 这个css选择器，就能找到页面中的最外层的div标签。 你也可以通过在开发者工具的console中输入 $(.container)，同样可以找到最外层的div标签。 前端工程师还需要经常使用 css 选择器编写页面样式，比如通过 css 选择器把 h2 标签的颜色改成红色： h2 { color: red } 上面的操作会把页面渲染成这样： 基本选择器 我们编写的.container 就是css 中的基本选择器，表示选择 class 属性包含 container 的元素。 1、* 示例：*#loginForm 含义：通用选择器，可以选择任意元素。示例表示选择 id 属性为 loginForm 的任意元素。 2、element 示例：form 含义：根据元素名称选择元素。示例表示选择标签名为 form 的元素。 3、# 示例：#loginForm 含义：根据元素 id 选择元素。示例表示选择 id 属性为 loginForm 的元素。 4、. 示例：.container 含义：根据元素 class 属性选择元素。示例表示选择 class 属性包含 contianer 的元素。 5、[attr=value] 示例：[name=&quot;username&quot;] 含义：根据元素属性选择元素。示例表示选择 name 属性等于 username 的元素。 属性选择器 属性选择器就是 [prop=value] 这种语法，它不仅支持相等操作，还有其他一些额外的用法也经常使用。 1、[attr] 示例：[name] 含义：具备 name 属性的元素 2、[attr*=value] 示例：[name*=&quot;user&quot;] 含义：name 属性包含 user 的元素 3、[attr^=value] 示例：[name^=&quot;user&quot;] 含义：name 属性以 user 开头的元素 4、[attr$=value] 示例：[name$=&quot;sername&quot;] 含义：name 属性以 sername 结尾的元素 5、[attr~=value] 示例：[name~=&quot;username&quot;] 含义：name 属性为 username，或者是一个以空格作为分隔的值列表，其中至少有一个值为 username，比如 name=&quot;username beauty&quot; 6、[attr|=value] 示例：[name|=&quot;username&quot;] 含义：name 属性为username，或者以username-作为前缀。比如 name=&quot;username-beauty&quot; 组合选择器 组合选择器可以组合多个元素，当使用一个元素不能达到效果时，可能会把两个甚至多个元素组合在一起进行选择。比如想选择 div 标签下的 form 标签，就需要用到组合选择器，更准确的说，是后代选择器，用 div form 表示。 除了后代选择器，组合选择器还有其他表示。 1、div &gt; h2 子代选择器。表示 div 标签下第一级子标签 h2，中间不能有其他层级。 2、label ~ input 兄弟选择器。表示 input 在 label 标签后面，并且共享同一个父节点。 3、label + input 紧邻兄弟选择器。表示 input 紧跟在 label 标签后面，并且共享同一个父节点，而 label ~ input 可以在两个元素中间插入其他的元素。 4、label, input 合并选择器。表示同时选择 label 和 input 元素。 伪元素和伪类 如果在html 中看到类似 :first-child 或者 :hover 这样的，你就是看到了一个伪元素或者伪类。举一些经常使用的伪类选择器。 1、:first-child 该元素是父级元素下的第一个子元素。 2、:last-child 该元素是父级元素下最后一个元素。 3、:nth-child(2) 该元素是父级元素下第 2 个元素，2可以修改。 4、:nth-last-child(2) 该元素是父级元素下倒数第 2 个元素。 5、:nth-of-type(2) 该元素是祖先元素下第 2 个元素，并且祖先元素名称和该元素一致。 css 选择器和 xpath 的比较 xpath 是另一种定位网页元素的技术，我们可以写一些例子对比一下它们之间的区别。 1、通过 id 定位 css：#loginForm xpath：//*[@id=&quot;loginForm&quot;] 2、通过 class 定位 css：.container xpath：//*[@class=&quot;container&quot;] 3、通过 name 属性定位 css：[name=&quot;username&quot;] xpath：//*[@name=&quot;username&quot;] 4、通过父子关系定位 css：div &gt; h2 xpath：//div/h2 5、通过祖先关系定位 css：div form xpath：//div//form 大体来说： 1、css 更加简洁，xpath 写法更复杂。 2、css 的检索效率更高。 3、css 支持伪元素和伪类。 4、xpath 支持函数，功能上更强大。 5、css 不支持通过文本定位。 总结 css 选择器是一种常用的定位网页的技术，在前端和自动化领域应用广泛。 可以在 f12，console 中编写 css 选择器表达式。 通用选择器有 *，element，.class，#id，[prop=value] 等。 属性选择器有 =, *=，$=，^=，~=，|= 等等。 组合选择器有 &gt;，~，+ 等等。 还有伪类定位。 参考： https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors http://www.ruanyifeng.com/blog/2009/03/css_selectors.html ","link":"https://yuz.one/shi-yong-css-xuan-ze-qi-ding-wei-wang-ye-yuan-su/"},{"title":"selenium 启动时会遇到哪些坑","content":"1、chrome 正受到自动测试软件的控制 提示： 解决办法： 网上有教程是禁用浏览器的 infobars 选项来取消这个提示，经过测试这个方法已经失效了。 option.add_argument('disable-infobars') 但是有另一种方式是可以成功隐藏提示框的。 from selenium import webdriver option = webdriver.ChromeOptions() option.add_experimental_option('useAutomationExtension', False) option.add_experimental_option('excludeSwitches', ['enable-automation']) driver = webdriver.Chrome(options=option) 2、浏览器提示 windows defender 防护 提示： 解决办法： 重新配置用户数据目录可以解决： option.add_argument('user-data-dir=/usr/you/data/dir') driver = webdriver.Chrome(options=option) 3、浏览器驱动版本不匹配 提示： &quot;selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 81&quot; 解决办法： 下载和浏览器兼容的驱动版本。chrome 浏览器比较稳定的驱动版本有 71 和 38，优先使用这两个版本的驱动，然后再使用和浏览器版本一致的驱动版本。另外，firefox 火狐浏览器的驱动更加稳定，可以多用火狐浏览器运行 ui 自动化。 4、找不到浏览器安装路径 提示： WebDriverException: unknown error: cannot find Chrome binary (Driver info: chromedriver=2.26.436362 (5476ec6bf7ccbada1734a0cdec7d570bb042aa30),platform=Windows NT 10.0.14393 x86_64) 解决办法： options = ChromeOptions() options.binary_location = &quot;C:\\\\Program Files\\\\Chrome\\\\chrome64_55.0.2883.75\\\\chrome.exe&quot; driver = webdriver.Chrome(options=options) 5、浏览器驱动没有放在环境变量 提示： 解决方法1： 把驱动放在任意位置，添加 executable_path 参数。 使用 windows 系统时，只能放在 c 盘，其他盘会继续报错。 driver_path = r'C:\\data\\chromedriver_71.exe' driver = webdriver.Chrome(executable_path=driver_path) 解决方法2： 使用 python 自动配置 path 变量 driver_path = r'C:\\data' os.environ['path'] += f&quot;;{driver_path}&quot; driver = webdriver.Chrome() 6、session 创建失败 提示： Session created failed 解决办法： options = ChromeOptions() options.add_argument(&quot;enable-automation&quot;) options.add_argument(&quot;--headless&quot;) options.add_argument(&quot;--window-size=1920,1080&quot;) options.add_argument(&quot;--no-sandbox&quot;) options.add_argument(&quot;--disable-extensions&quot;) options.add_argument(&quot;--dns-prefetch-disable&quot;) options.add_argument(&quot;--disable-gpu&quot;) driver = webdriver.Chrome(options=options) 7、汇总后的浏览器设置 import os from selenium import webdriver def start_selenium(driver_path, user_dir, browser_path): options = webdriver.ChromeOptions() # hide info bar options.add_experimental_option('useAutomationExtension', False) options.add_experimental_option('excludeSwitches', ['enable-automation']) # change browser user data dir options.add_argument(f'user-data-dir={user_dir}') # browser binary location options.binary_location = browser_path # insert web driver path into os path variable os.environ['path'] += f&quot;;{driver_path}&quot; # others options.add_argument(&quot;enable-automation&quot;) options.add_argument(&quot;--headless&quot;) options.add_argument(&quot;--window-size=1920,1080&quot;) options.add_argument(&quot;--no-sandbox&quot;) options.add_argument(&quot;--disable-extensions&quot;) options.add_argument(&quot;--dns-prefetch-disable&quot;) options.add_argument(&quot;--disable-gpu&quot;) driver = webdriver.Chrome(options=options) ","link":"https://yuz.one/selenium-qi-dong-shi-hui-yu-dao-na-xie-keng/"},{"title":"读取excel测试数据真的慢吗？","content":"在实现自动化测试的时候，我们经常会使用数据驱动。所以我们经常会把测试数据单独保存在一个特定格式的文件当中，然后通过读取文件去驱动自动化测试代码。 这篇文章会对比excel、csv 和 yaml三种主流的文件格式，看看它们哪个更好。 先来看用的最多的Excel。 excel是世界上使用最广泛的数据文件格式。使用python做自动化测试，可以用openpyxl这个第三方库操作excel。 经常有人说 Excel的操作限制很多，写入和读取的速度很慢。真的是这样吗？ 我们做个实验。创建一个空的Excel文件，然后插入1000条数据，看插入数据和读取这些数据会耗费多久的时间。 import openpyxl def test_insert_1000_lines_data(): lines = 1000 workbook = openpyxl.Workbook() worksheet = workbook.create_sheet('demo') for i in range(lines): data = (i, f'name{i}', f'http://www.example.com/{i}') worksheet.append(data) workbook.save('1000lines.xlsx') def test_read_1000_lines_data(): workbook = openpyxl.load_workbook('1000lines.xlsx') worksheet = workbook['demo'] for row in worksheet.values: pass 插入1000条数据会消耗多少时间呢？答案是0.09秒，速度并不慢。而读取这1000条测试数据消耗的时间，只需要0.06秒。 在一个项目当中，1000个测试用例应该是比较合理的，所以在正常的测试场景下，使用excel管理用例数据在读取效率上是合适的。 但是当数据变得越来越大的时候，Excel的处理速度会越来越慢，读取数据消耗了7秒。这就意味着如果你有多个项目需要同时测试，excel的解析可能会对测试效率造成一定的影响。 1000行 5万行 10万行 插入时间 0.09s 3.75s 7.44s 读取时间 0.07s 3.45s 7.1s 再看 csv 格式。 不论是进行自动化测试还是进行数据分析，csv格式都更加合适。这种格式不像Excel，要去处理表格的样式，它更专注于数据。 而且在Python语言当中，内置了csv格式的处理模块，用法非常简单，没有太多额外的学习成本。 import csv def test_insert_1000_lines_data(): lines = 1000 with open('1000lines.csv', 'w', newline='') as f: csv_writer = csv.writer(f) for i in range(lines): data = (i, f'name{i}', f'http://www.example.com/{i}') csv_writer.writerow(data) def test_read_1000_lines_data(): with open('1000lines.csv', newline='') as f: csv_reader = csv.reader(f) for row in csv_reader: print(row) 分别对1000行、5万行和10万行数据进行插入和读取操作，csv 的速度都比excel要快一个量级。 1000行 5万行 10万行 插入时间 0.08s 0.09s 0.17s 读取时间 0.02s 0.04s 0.09s 对于海量数据处理，csv 比 excel 要快很多，代码编写也更简单。 但是，使用csv格式一定要注意对逗号的处理。 在csv当中，每一行的数据默认是用逗号分割的，如果你有一个数据当中本身就包含了逗号，一定要记得把这个数据用双引号包裹。 而且，csv 支持的数据格式非常有限，数据被读取出来后都被当成字符串，需要自己添加额外的解析操作。 id,17,18,&quot;{'name': 'yuz', 'age': 11}&quot; 最后，我们来看看 yaml 的表现怎么样？ yaml 的优点在于丰富的数据类型支持。无论是元组、字典、数字、布尔类型都能支持，并且被 python 语言轻松解析成对应的 python 数据类型。 import yaml def test_insert_1000_lines_data(): lines = 1000 with open('1000lines.yaml', 'w') as f: all_data = [{&quot;id&quot;: i, &quot;name&quot;: f&quot;name{i}&quot;, &quot;data&quot;: {&quot;username&quot;: &quot;yuz&quot;, &quot;passoword&quot;: 123456}} for i in range(lines)] yaml.safe_dump(all_data, f) def test_read_1000_lines_data(): with open('1000lines.yaml', encoding='utf-8') as f: data = yaml.load(f, Loader=yaml.SafeLoader) 在少量数据的解析上，yaml 会非常的方便。但是一旦数据增加到上万组，yaml的解析速度会非常非常慢。当数据达到10万行的时候，读取速度竟然接近 1 分钟。 1000行 5万行 10万行 插入时间 0.27s 14.79s 31.78s 读取时间 0.47s 26.8s 53.63s 最近有越来越多的自动化测试人员使用yaml存储用例，一方面是看重了它支持的丰富的数据格式，另一方面可能是受了一些框架的影响。 httprunner这个接口自动化测试框架就采用了yaml存储用例数据。其实当存在海量数据需要读取的时候，yaml 的处理速度比Excel慢一个量级。所以httprunner 这样的框架，从测试效率这个维度来讲，更适合做单用例或者少量用例的测试。如果想针对整个项目甚至是多个项目一次性测试的话，httprunner 的执行速度会比较慢。 通过对Excel、csv和 yaml 三种格式的操作效率对比可以得出以下结论。 一、如果你只想对少量的用例进行测试，或者对测试数据的格式要较高的要求，用yaml存储用例数据会更利于解析，但是这种场景下一般可以直接使用 postman 这些成熟的工具，没有必要自己实现。 二、如果你已经习惯了Excel的操作。直接使用这种方式就可以了，1万行以下的数据， Excel还是非常快的。 三、不管怎么样，我还是更推荐大家去尝试一下csv这种格式。首先、就算是到了10万行数据的情况下，它的处理速度也是非常快的。其次，Python语言当中直接内置了csv的模块，它的使用方式和 open.函数非常的相似，几乎没有额外的学习成本。 ","link":"https://yuz.one/du-qu-excel-ce-shi-shu-ju-zhen-de-man-ma/"},{"title":"数据驱动不适合做 UI 自动化测试","content":"在做自动化测试的时候，我们经常会听到 DDT 数据驱动测试（Data-Driven Testing)。 数据驱动测试又叫做表格驱动测试或者参数化驱动测试。它指的是进行自动化测试时，把所有测试数据单独放在一个表格或者是独立的模块儿当中，当运行测试脚本的时候，在一个通用的测试逻辑中分别填入每一组测试数据。 数据驱动可以解决两个问题。一、避免硬编码和重复代码，二、独立维护测试数据的表格，不需要频繁修改和维护代码。 在流程驱动中，一般来说是一个测试用例会对应编写一个测试脚本或者函数。如果每个用例需要执行的步骤相同，就会出现大量的重复代码。而且当测试用例需要修改的时候，需要维护大量的代码函数。 数据驱动可以有效解决这两个问题。它只需要编写一个通用的测试函数，然后通过参数化的手段将每一行测试数据分别带入函数作为参数，不仅节省了大量的重复代码，而且当测试用例需要修改的时候，也只需要修改对应的表格文件，而不需要去修改代码。 数据驱动当然是一种好的自动化测试方式，但是有些人还是对它有不少误解。第一种误解，以为把测试数据存在 excel 当中，就是数据驱动。实际上，除了excel表格，csv文件、yaml 文件、json 文件和数据库都可以作为数据驱动的表类型，也可以直接用编程语言当中的数据类型存储。 第二种误解，有些人觉得数据驱动是万能的，只要做自动化测试一定要用数据驱动。实际上数据驱动的使用场景也是比较有限的，他只适合在所有测试数据共享同一套代码逻辑的测试场景下。 其中最典型的就是接口自动化测试。 接口自动化测试下，测试逻辑几乎都是一致的：获取请求的url地址、请求方法、请求参数，传入客户端中，获取服务器的响应数据。 @pytest.mark.parametrize('url, method, data', table_data) def test_login_(url, method, data): resp = requests.request(method, url, json=data) 但是 ui 自动化测试，每个用例需要执行的动作和测试步骤都会有很大的区别。要实现数据驱动，只能通过把数据分组，每一组共享一个测试函数的方式。但是这种形式要同时维护多张数据表和多个函数，还不如采用硬编码，一个用例对应一个测试函数维护起来方便。 import pytest # 维护多个 excel 表格 excel_1 = read_excel('1') excel_2 = read_excel('2') excel_3 = read_excel('3') # 维护多个函数 @pytest.mark.parametrize('case', excel_1) def test_login_group_1(): pass @pytest.mark.parametrize('case', excel_2) def test_login_group_2(): pass @pytest.mark.parametrize('case', excel_3) def test_login_group_3(): pass 那么 ui 自动化测试适合使用什么方式呢？ 第一种方式就是采用硬编码这种最直接的方式。 每个用例单独编写一个测试函数，测试数据可以通过变量保存在测试函数最开始的位置，可以避免到处找测试数据的尴尬。这种方式只是把之前维护数据表格的工作转移到维护测试函数上来，虽然会多写一些重复代码，但是维护起来也不是特别困难。 def test_login_1(): username = '' password = '' login(username, password) def test_login_2(): username = 'error name' password = '123456' login(username, password) def test_login_3(): username = 'real name' password = 'correct password' login(username, password) 也可以结合数据驱动，采用数据分组编写测试函数的方式，但是不要独立去维护excel表格了，而是直接在测试代码里使用编程语言的数据类型存储分组数据，减少代码维护的成本。 import pytest group_1 = [ (&quot;&quot;, &quot;&quot;)] group_2 = [ (&quot;error name&quot;, &quot;&quot;)] group_3 = [ (&quot;correct name&quot;, &quot;&quot;)] @pytest.mark.parametrize('name, password', group_1) def test_login_group_1(name, password): login(name, password) @pytest.mark.parametrize('name, password', group_2) def test_login_group_1(name, password): login(name, password) @pytest.mark.parametrize('name, password', group_3) def test_login_group_1(name, password): login(name, password) 第二种方式可以使用关键字驱动。 关键字驱动和数据驱动的区别在于：不仅隔离了数据，而且把需要执行的动作也以字符串的形式，存放到表格当中。和数据驱动相同的是，它还是只有一个通用的测试执行函数。当运行测试脚本时， 每条数据和动作会一起作为参数传入执行函数中。 我们来举一个实际的例子，首先创建一个yaml 文件存储一条用例的所有测试步骤、需要调用的操作和数据。 - action: &quot;goto&quot; params: url: &quot;https://prepc.ketangpai.com/#/login&quot; - action: &quot;type&quot; params: locator: ['xpath', '//input[@type=&quot;text&quot;]'] data: 'looker53@sina.com' - action: &quot;type&quot; params: locator: ['xpath', '//input[@type=&quot;password&quot;]'] data: 'admin123456' - action: &quot;click&quot; params: locator: ['xpath', &quot;//div[@class='margin-top']//button[@type='button']&quot;] 然后编写一个通用的函数调用 yaml 中的动作和数据： import yaml fpath = r'C:\\Users\\muji\\Desktop\\ketangpai_web_testing\\data\\login_ok.yaml' with open(fpath, encoding='utf8') as f: data = yaml.safe_load(f) def test_keyword(driver): for step in data: method = getattr(driver, step['action']) method(**step['params']) 动作需要提前写在某个固定的模块或者类当中，然后通过 getattr 这种动态获取动作的操作从类中提取动作，再传入测试数据。比如上面的例子中，goto、type、click 动作都被保存在一个 Driver 的类中。 数据驱动是一种很好的模式，在进行接口自动化测试这样统一步骤的场景下非常有用。再 ui 自动化测试时，用硬编码或者关键字驱动会更加合适。 参考资料： https://www.guru99.com/data-driven-testing.html https://en.wikipedia.org/wiki/Data-driven_testing https://www.cnblogs.com/fnng/p/9557710.html ","link":"https://yuz.one/shu-ju-qu-dong-bu-gua-he-zuo-ui-zi-dong-hua-ce-shi/"},{"title":"jsonpath 教程","content":"jsonpath[1] 是一种解析 json 数据的技术，主要用来快速提取 json 数据当中的某部分内容。 先来看一个例子。 某个接口返回了一个 json 数据，现在需要把 json 数据当中的 city 值提取出来。 { &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot; : &quot;doe&quot;, &quot;age&quot; : 26, &quot;address&quot; : { &quot;streetAddress&quot;: &quot;naist street&quot;, &quot;city&quot; : &quot;Nara&quot;, &quot;postalCode&quot; : &quot;630-0192&quot; }, &quot;phoneNumbers&quot;: [ { &quot;type&quot; : &quot;iPhone&quot;, &quot;number&quot;: &quot;0123-4567-8888&quot; }, { &quot;type&quot; : &quot;home&quot;, &quot;number&quot;: &quot;0123-4567-8910&quot; } ] } 如果使用 jsonpath 技术，可以先写好 jsonpath 表达式： $.address.city 然后通过在线jsonpath解析网站可以得到结果，所有匹配的结果会存在一个元组当中。 [&quot;Nara&quot;] jsonpath 语法 JSONPath 描述 示例 $ 根目录对象，提取所有 $ . 或者 [] 子元素 .age、.age 、.age、[age] 、$['age'] .. 子孙元素 $..number [0] 或者 .0 索引 phoneNumbers[0] [0:2:step] 切片 phoneNumbers[0:2] [0,1] 联合、或者 phoneNumbers[0,1] * 通配符 address.* 、address[*] @ 当前对象或元素，通过和 () 一起使用 phoneNumbers[(@.length-2)] ?() 过滤表达式 phoneNumbers[?(@.type==&quot;iPhone&quot;)] 分别来看看这些表达式的结果吧： $..number， 提取所有 key 为 number 的值 phoneNumbers[0] 或者 phoneNumbers.0 ，获取 phoneNumbers 下面的数组第一个元素， jsonpath 的索引是从 0 开始的。 phoneNumbers[0].type 或者 phoneNumbers.0.type phoneNumbers[0:2] 或者 phoneNumbers.0:2， 结尾位置不包含在内。 phoneNumbers[0:2].number 或者 phoneNumbers.0:2.number phoneNumbers[0,1].number 或者 phoneNumbers.0,1.number address.* 或者 address[*] 注意和 address 区分哦： [ { &quot;streetAddress&quot;: &quot;naist street&quot;, &quot;city&quot;: &quot;Nara&quot;, &quot;postalCode&quot;: &quot;630-0192&quot; } ] phoneNumbers[(@.length-2)] 获取phoneNumbers 下面的元组长度 - 2 的元素，等价于 phoneNumbers[0] 对于数组，可以使用过滤。过滤 phoneNumbers[?(@.type==&quot;iPhone&quot;)] 正则表达式。phoneNumbers[?(@.type =~ &quot;^h.*&quot;)] jsonpath-ng jsonpath-ng[2] 是 python 解析 json 数据的一个库。融合了 jsonpath-rw 和 jsonpath-rw-ext 的用法，支持正则等扩展操作。 from jsonpath_ng.ext import parse s = {&quot;phoneNumbers&quot;: [ { &quot;type&quot; : &quot;iPhone&quot;, &quot;number&quot;: &quot;0123-4567-8888&quot; }, { &quot;type&quot; : &quot;home&quot;, &quot;number&quot;: &quot;0123-4567-8910&quot; } ] } # 使用正则表达式匹配 home parser = parse('phoneNumbers[?(@.type =~ &quot;^h.*&quot;)]') resp = parser.find(s) https://goessner.net/articles/JsonPath/ ↩︎ https://pypi.org/project/jsonpath-ng/ ↩︎ ","link":"https://yuz.one/jsonpath-ng-jiao-cheng/"},{"title":"使用 python 操作数据库，只需要掌握 dataset","content":"使用 python 操作数据库一般使用两种方式。 方式一：通过 pymysql 这样的数据库引擎。它的优势是使用灵活，API 比较底层，自定义程度高。但是每种数据库的操作都需要单独学习用法，如果之前用的 mysql，切换到 Oracle 可能要重新学习另一个库。 方式二：通过 sqlalchemy 这样的 ORM。它的优势是不同数据库通用，而且不需要写 sql 语句，而是通过面向对象的方式编写数据库操作，可读性更强。 但是 ORM 的学习成本比较高，而且通常用在开发，对于小型的脚本施展不开。 dataset 是介于这两者之间的选择。 首先，对于不同的数据库，都有相同的操作，不需要像 pymysql 这样，每换一个数据库就要学习新的内容。 其次，使用起来也非常简单。在以后的数据库操作中，我会多尝试用这个库。 安装 pip install dataset 连接数据库 import dataset url = 'mysql+pymysql://username:password@8.129.91.153:3306/database' db = dataset.connect(url) 数据库 URI 数据库的连接信息通过一个标准格式的 URI 表示，只需要遵循以下的写法。 sqlite 有点特别，因为它只是本地的文件： url = 'sqlite:///path/of/mydatabase.db' 获取表 from dataset import Table table: Table = db['table_name'] 查询一条记录 得到的是一个 OrdererDict 排序字典。 record = table.find_one(id=3) 查询多条记录 得到的是 ResultIter 可迭代对象。 record = table.find(id=3) 复杂 sql 语句 因为上面的操作都是基于单表操作，如果涉及到多表操作，或者一些复杂的查询并不实用。 可以使用 db.query。 result = db.query('SELECT type, COUNT(*) c FROM member GROUP BY type') query 传参数 result = db.query('SELECT mobile_phone, leave_amount FROM member ' 'WHERE type = :type and leave_amount &gt; :amount', type=1, amount=90000) 完整的流程 import dataset url = 'mysql+pymysql://future:123456@8.129.91.152:3306/futureloan' db = dataset.connect(url) table = db['member'] record = table.find_one(id=3) 插入 info = dict(name='yuz', age=11, phone='18122223333') success = table.insert(info) 更新 info = dict(name='yuz', age=22, phone='12188889999') res = table.update(info, keys=['name']) 查找 name 等于 yuz 的记录，把他们的 age 和 phone 修改成新的数据。 事务 with dataset.connect() as db: db['user'].insert(dict(name='yuz', age=4=, phone='12188889999') 当操作失败时，所有数据会回滚到之前的记录。上面的操作等价于： db = dataset.connect() db.begin() try: db['user'].insert(dict(name='yuz', age=4=, phone='12188889999') db.commit() except: db.rollback() 参考 官网 ","link":"https://yuz.one/shi-yong-python-cao-zuo-shu-ju-ku-zhi-xu-yao-zhang-wo-dataset/"},{"title":"faker库生成数据","content":"faker库用于生成伪造的数据。 设置中文 from faker import Faker fk = Faker(locale='zh_CN') 设置多语言 from faker import Faker fk = Faker(locale=['zh_CN', 'en_US']) 手机号码 In [4]: fk.phone_number() Out[4]: '13184685252' 地址 In [5]: fk.company() Out[5]: '商软冠联信息有限公司' 公司 In [6]: fk.address() Out[6]: '广西壮族自治区通辽市沙市张路b座 217717' 时间 In [7]: fk.date_time() Out[7]: datetime.datetime(1983, 12, 8, 21, 53, 41) 自定义 Provider 如果发现内置的数据不是你想要的，可以自己定义实现。 from faker import Faker from faker.providers import BaseProvider class PY36(BaseProvider): names = ('雨泽', '鲸鱼', '猴子', '阿鸡') def py36_name(self): return self.random_element(self.names) # 添加provider fk = Faker(locale='zh_CN') fk.add_provider(PY36) print(fk.py36_name()) pytest 夹具 安装好 pytest 和 faker 以后，可以直接使用以下测试夹具生成数据。 @pytest.fixture(scope='session', autouse=True) def faker_session_locale(): return ['zh_CN'] @pytest.fixture() def mobile(faker): return faker.phone_number() unique seed Factory 参考文献 官网 python最假的库 ","link":"https://yuz.one/faker-ku-sheng-cheng-shu-ju/"},{"title":"制作一个视频需要用到哪些工具","content":"前几天又背了一遍 OSI 网络七层协议，七个单词背了半个小时。要是哪天去面试，肯定要扑街。我这么爱学习的肯定不能坐以待毙啊，赶紧在网上搜了一堆资料帮助我理解这个模型，很开心找到一个很有意思的国外视频资料。这个视频使用动画的方式形象的讲解了七层模型中的每一层具体干了什么事情。 不过这个动画没有字幕，口语也不是很标准，估计是个印度哥儿们。这么好的内容，不加字幕却看不懂，那我自己配个字幕，有事没事可以拿出来复习下。 IDM 下载 首先我要把视频下载下来。网上有很多下载工具和插件可以下载视频网站的视频，这里我要推荐 2 个工具。第一个工具是命令行工具 you-get 非常强，支持几乎所有主流视频网站，操作简单，速度奇快。 如果需要访问国外网站可能需要加代理。先打开代理软件，然后在命令行添加 -s 配置本地代理端口。 you-get -s http//:127.0.0.1:10808 https://www.target-site.com 第二个是我平时用的界面下载工具 IDM，支持大多数视频网站的视频下载。IDM 的全称是 Internet Download Manager，软件需要收费，界面朴素，但是功能强大，速度飞快。 打开 IDM 后，会智能识别当前页面可以被下载的视频和音频，直接点击即可下载。 需要注意的是，国外网站如果无法访问需要在 IDM 中设置代理，直接选择系统代理就可以啦。 视频剪辑 视频剪辑工具现在非常多，但是我挑了一圈也没挑到合适的，后面选了 ev 剪辑，操作简单，不需要专业知识，但是剪完以后有水印，而且又大又亮，要付费才能去掉。 算了，穷，忍一忍。 其实现在视频平台都有非常强大的官方剪辑工具，但是一般只有手机版。某抖的剪映是用得最多的，出了 mac 电脑版，windows 版迟迟没有动静。还有某微的秒简，某 B 的必剪，某快的快影。 电脑端找到两个开源的：opencut 和 shotcut。 视频剪辑后体积不仅没变小，反而大了很多，不知道是不是所有的剪辑软件都是这样。 网上说是下载的视频都是压缩过的，用剪辑软件打开之后又还原了。 好吧，反正我也不懂，你们说什么就是什么，后面我再用压缩工具压缩回去。 字幕添加 首先你需要有语音识别生成字母的软件，当然也可以自己练听力手动保存到文件中，别笑，我就是手动操作的。 字幕生成有网易的 见外 和讯飞的听见。 随着B站、抖音的崛起，添加字幕也越来越流行，工具也多起来。不过大家似乎都对 Arctime 这款软件非常喜欢，我也就直接用了。使用上没槽点，尤其是用拖拽的方式添加字母非常顺手。 视频压缩 视频压缩工具好用的也开始收费了，找到了一个离线工具 Free Video Compressor。界面简单，操作粗暴，可以根据最终体积智能压缩。 这款工具还可以做简单的剪辑，控制视频输出大小和比率，适合我这样的外行。 也用过其他的在线工具。上传等了15分钟，压缩完体积没啥变化，然后让我交钱进一步压缩，浪费了比较多时间。为什么不一开始就说明收费呢？好用自然会有人付费的。 远程传输 在电脑上剪辑完视频，如果需要传到手机上，可以借助一些文件传输工具。 我觉得这种工具就是越简单越好了，直接选了搜索引擎排名第一的奶牛快传，操作傻瓜，在电脑端先把文件传上去，工具会显示文件的获取地址，或者取件码， 在手机端访问就可以完成下载。 就是传输速度有点慢。 这种工具实现起来也不难，如果到时候软件无法正常经营撑，自己写一个局域网工具也可以。 现在，你可以在 B站 看到这个视频。这次制作非常粗糙，也因此明白了视频制作的困难，要做好一个视频内容真的很不容易。本文涉及软件比较多，如果你有更好的工具推荐，麻烦联系我微信：shoubian01 ","link":"https://yuz.one/wo-zuo-liao-hui-shi-pin-gao-su-ni-xu-yao-yong-dao-na-xie-gong-ju/"},{"title":"感谢 Gridea，让我有动力写作","content":"1. 真的要感谢 Gridea，让我对写作产生热忱。一直有在各大博客平台输出的习惯，但是都没有持续更新。有的平台广告太多，写不下去。有的平台排版复杂，写文章1个小时，排版要2个小时。所以后面换成了静态博客生成器，比如说像 JS 的 Hexo，Go 语言的 Hugo，还有 Python 的 Pelican，但是这些博客平台又有一个缺陷，当我写完了文章以后，还要进行一些额外操作，才能同步到网上，无形之间增加了写作的成本。 写作是一个累人的活，很容易失去动力，养成这个习惯最好马上动手，看到效果，如果有麻烦的操作就会迅速打消积极性。 用了 Gridea 以后，我的写作积极性明显变高，每天都有强烈的冲动，想把做的事情记录下来，写作的频率明显变高。当然这可能是出于对这个工具的新鲜感，但是无论如何，我希望这个工具能让我养成写作的好习惯。 2. Gridea 支持 Windows 系统，MAC系统和 Linux 系统。首先我们在 Gridea 的官网下载 客户端，安装完成以后就可以直接编写文章了。 ! 编写好的文章，除了能在 Gridea 界面上看，到以外还会保存到本地。查看存放的本地路径，点击界面的左下角设置按钮，就可以看到。 Gridea 使用 markdown 格式编写文章。如果你不知道 Markdown格式，你可以先学习一下。文章编写完成以后，可以自定义 meta 信息，可以在写作界面右边找到他，边上还有预览按钮。 可以设置的信息包括：URL、标签、创建时间、封面图、隐藏和置顶。 这些信息设置好以后，可以在 Markdown 源文件中查看。你可以使用任意支持 Markdown 的编辑器打开源文件，meta 信息会显示在文章的最上面。 有时候你会对在文章中插入图片，这些图片也可以在本地找到。直接找到 Gridea 源文件路径，你会发现有一个 post-images 目录，这个目录下就存放了所有文章的图片。 3. 影响写作的另外的一个主要因素是，写完文章以后阅读的体验好不好。现在，在文章列表的左下角点击预览按钮，就可以看到博客实际发布的样子了。 博客发布以后样式是可以通过主题更改的。你可以在主题菜单栏，选择自己喜欢的主题。 Gridea 现在内置4 个主题，分别是：Fly、Simple、Note、Paper，这4个主题的显示风格都比较优雅，不像其他平台的默认主题那样丑。 如果你需要一个其他的主题，可以在 Gridea 官网的 主题页面 选择，这里面大多数都是免费的，付费的主题价格便宜，看起来比免费的优雅一些。 目前我使用的是 pure 这个主题。它是没有内置在 Gridea 的客户端里面的，所以需要先 下载。下载之后解压放到 Gridea 源文件的 themes 目录下，你就可以在主题界面选择这个主题了，是不是非常简单？ 4. 接下来我需要把文章同步到网上。我自己没有申请域名和服务器，所以选择了 Github Pages 提供的静态网站托管服务。我需要做的就是申请一个 Github 的账号，然后创建一个 github_name.github.io 的 Repo，请参看详细的 官方配置手册。配置完成以后先点击测试按钮看看是否能连接到 Github。 当一切配置好了以后，点击同步按钮，把文章发布到 Github Page。 Gridea 其实也没有做特别复杂的事情，它还是使用了 Hexo 这样的静态网站生成器。只是它编写了一个图形界面，让我们使用起来更加便捷。 在同步博客的时候，我们不需要记住各种各样的命令，只需要在图形界面上进行点击和输入就可以了。这极大的简化了我们发布博客的流程。 Gridea 这个产品的开发思路非常好，非常支持他对优秀主题收费，现在发布的三款收费主题并不是我想要的，之后如果有我喜欢的主题，我会考虑购买。 ","link":"https://yuz.one/gan-xie-gridearang-wo-you-dong-li-xie-zuo/"},{"title":"使用 mkdocs 搭建博客和编写文档","content":"平时比较懒，写的文章和羊拉屎一样，东一点，西一点，散落在各个平台。 一直想把所有的文章都放在一个统一的地方，可以起到备份作用，同时也希望有一个自己的窝。 以前也尝试用过 hexo 和 Hugo 这样的静态博客，搭配上主题还是非常舒服的。不过功能上偏向博客需求，如果想定制一些专题写作计划，实现起来比较麻烦。 经过一番折腾，决定把文章签到到文档生成器上，看起来会系统一些，当然也会存在一些问题，比如标签管理和编写时间的缺失。任何计划都有利有弊，还是先做一个出来再说。 选择 mkdocs 还是 sphinx 因为自己主要使用 python 语言，所以还是使用 python 开发的工具会比较有安全感，如果真遇到问题，至少可以通过源码去排查问题。python 其实也有 pelican 这样的静态博客生成器，使用起来也非常方便。在文档生成器上，主要有 2 个主流的：mkdocs 和 sphinx。 很多大佬写的框架都是 sphinx 编写的，比如 requests 库就是通过 sphinx 部署在 readthedocs 平台上。 mkdocs 用来会简单一些，而且越来越多的新框架使用 mkdocs 编写文档，像 web 开发框架 FastAPI。 看了一下 sphinx 和 mkdocs 的官方文档，mkdocs 会清晰一些， sphinx 看起来有点复杂。 又查看了 GitHub 上面两个库的 star 数，最后还是选择用 mkdocs。 安装 mkdocs mkdocs 使用 python 语言编写，先要下载 python 环境，然后通过 pip 安装： pip install mkdocs 接下来使用 mkdocs 命令进行操作，命令主要有 4 个： build, 把 markdown 文档转成 html 页面，在网页中呈现的效果就是 build 之后的 html 文档； gh-deploy, 部署文档到 GitHub Pages, 主要作用是把生成的 HTML 文档放到 gh-pages 分支当中，然后让 GitHub Pages 显示 gh-pages 分支当中 HTML 页面； new 生成一个新的项目，其实就是创建一个 mkdocs.yml 的配置文件和 doc 目录存储 markdown 文件； serve 运行服务器，通过自己的方式在本地或服务器部署，内部是使用 tornado 作为服务器运行。 先在任意目录下创建一个项目： mkdocs new . 此时目录下会有一个 mkdocs.yml 文件和一个 docs/ 的子目录，子目录下面有一个 index.md 的文件。 在 mkdocs 中写文章 docs/index.md 文件就是整个项目的首页，在本地开启服务： mkdocs serve 通过浏览器访问 http://localhost:8000， 就可以看到 index.md 当中的内容了。 如果有新的文章，直接在 docs 目录下创建 markdown 文件。需要创建专题或者分类，可以创建子文件夹，mkdocs 默认会把这些文件放到导航栏展示出来。 修改主题 mkdocs 可以修改主题，改变页面的展示效果。 修改为内置主题只需要在 mkdocs.yml 文件中添加 theme 配置选项： theme: name: readthedocs 再次访问页面，网站的展示就变成了 readthedocs 样式了。readthedocs 主题是自带的，不需要额外安装。 如果需要安装第三方的主题，先要安装才可以使用。我们来看一下 FastAPI 的文档主题 mkdocs material, 这个主题在 GitHub 上有 5.1k 的 star, 非常火爆。 首先通过 pip 安装： pip install mkdocs-material 再配置 mkdocs.yml 文件, 就可以使用这个模板了。 theme: name: material mkdocs 也支持自定义主题。这里就不折腾了，感兴趣的可以自己查资料。 配置导航 mkdocs material 主题 默认是不配置导航的，要开启主题的功能，继续配置 mkdocs.yml 文件，要获得各种效果，基本上只需要配置这个文件。 theme: name: material features: - navigation.tabs 有时候你并不行把所有的目录都作为导航 tab 展示出来，你需要自己定义导航，同样可以在 mkdocs.yml 文件当中配置。 可以嵌套多级路径，但是只有顶层会显示在 tab 中，剩下的会在侧边栏展示。 nav: - 首页: index.md - 编程: - python: python/index.md - golang: golang/index.md 网站风格设置 官方网站有非常多风格设置的说明，可以设置外观颜色，markdown 进阶语法和 emoji 表情等等。下面是一个参考的 mkdocs.yaml 设置： site_name: My Docs theme: name: material # 设置中文 language: zh palette: # 主色调 primary: brown features: - navigation.tabs nav: - 首页: index.md - 编程: - python: python/index.md - golang: golang/index.md markdown_extensions: - admonition - attr_list - codehilite: guess_lang: false linenums: false - toc: permalink: true - footnotes - meta - def_list - pymdownx.arithmatex - pymdownx.betterem: smart_enable: all - pymdownx.caret - pymdownx.critic - pymdownx.details - pymdownx.emoji: emoji_generator: !!python/name:pymdownx.emoji.to_png - pymdownx.inlinehilite - pymdownx.magiclink - pymdownx.mark - pymdownx.smartsymbols - pymdownx.superfences - pymdownx.tasklist - pymdownx.tilde 发布到 GitHub Pages 第一步：在 github 账号上创建一个库名为：&lt;username&gt;.github.io，把远程仓库的名称添加到本地仓库： git remote add github https://github.com/yourname/yourname.github.io.git 第二步：生成对应的 HTML 文档，文档会被放到 gh-pages 分支下： mkdocs gh-deploy 第三步：把本地仓库 push 到远程仓库地址，注意要把 master 分支和 gh-pages 分支都推送： git push github --all 这里的 github 是远程仓库的名称，你也可以取其他的名字。 第四步：在 github 的项目设置里设置默认分支为 gh-pages 分支: 访问 looker53.github.io 就可以看到项目了。 ","link":"https://yuz.one/shi-yong-mkdocs-da-jian-bo-ke-he-bian-xie-wen-dang/"},{"title":"TOML 配置文件简明教程","content":"今天我们一起来学习toml这种简洁的配置文件格式吧。 TOML是在 2013 年发布的配置文件格式。距今虽然有8年历史了，但是之前一直没有在大项目中见过的。我是前段时间在看python的pep规范，无意中看到了这种配置文件格式，稍微了解了一下，才发现现在有很多新的明星项目都喜欢用它来做配置文件。 1、有rust语言的包管理工具cargo； 2、类似于docker的容器工具containerd； 3、go语言很多项目都喜欢用。比如静态网站生成工具Hugo、数据库InfluxDB、GitLab CI。 4、python项目也开始接纳。包管理工具 pip、pipenv和Poetry都是用的TOML,[1]现在连官方的metadata管理也开始支持toml。 1. 一个小例子 为什么新项目这么喜欢 TOML 呢？ 让我们先来看一个TOML的小例子吧，看完了说不定你就知道了。 [project] name = &quot;spam&quot; version = &quot;2020.0.0&quot; description = &quot;Lovely Spam! Wonderful Spam!&quot; readme = &quot;README.rst&quot; requires-python = &quot;&gt;=3.8&quot; license = {file = &quot;LICENSE.txt&quot;} keywords = [&quot;egg&quot;, &quot;bacon&quot;, &quot;sausage&quot;] 有没有感觉很熟悉呢？它和ini格式的配置文件几乎一模一样。要知道互联网发展到今天，大多数有影响力的项目都是采用ini这种配置文件格式，如果你之前有接触过ini，切换到toml几乎是0成本。 那为什么不直接用ini呢？因为ini格式支持的数据类型非常少，配置项的值都会被默认当成字符串，如果想表示数字、数组，还需要自己进行额外的解析。 但是在TOML中，数据类型非常丰富： 字符串 注释 数字 布尔值 数组 哈希表 甚至连时间格式都支持 2. 字符串 字符串我们当然不会陌生，但是如果你是从ini格式转过来的，一定要注意字符串值要加引号。 键默认会当成字符串处理，可以加也可以不加。 加引号的键叫引号键（Quoted Key）,不加引号的键叫裸键（Bare Key)。 TOML 格式非常灵活，对于灵活的语言，最好的方式是给自己设置规范和纪律，一直用好一种用法，不然很容易学废。官方推荐我们尽量用裸键，当裸键不能正确表达意思的时候，再用引号键。 name = &quot;spam&quot; #OK name_1 = spam #错误 &quot;name_2&quot; = &quot;spam&quot; #OK 裸键只能包含 ASCII 字母，ASCII 数字，下划线和短横线（A-Za-z0-9_-），引号键则可以支持特殊字符，甚至是空格。当键中包含特殊字符的时候，使用引号键。 'name@! erf:' = 'spam' # OK name@! erf: = 'spam' # 错误 当字符串为多行字符串时使用三引号，会自动换行： name = &quot;&quot;&quot; this is a new line command&quot;&quot;&quot; 得到的结果是： this is a new line command 如果不想自动换行，只是想增强可读性，可以使用折行符号\\： name = &quot;&quot;&quot; this is a \\ new line \\ command&quot;&quot;&quot; 得到结果是不换行的： this is a new line command 3. 数字 如果你都会编程了，数字应该会知道怎么表示。 age1 = 18 age2 = -2 age3 = +16 age4 = 11.2 toml除了支持10进制表示，还支持二进制（0b）、八进制（0o）、十六进制（0x） age1 = 0b11 age2 = 0o12 age3 = 0xb 上面的解析结果为： { 'age1': 3, 'age2': 10, 'age3': 11 } 4. 布尔 bool1 = true bool2 = false 5. 时间 时间类型是toml的一大特色，因为绝大多数的配置文件格式都是不支持时间类型的。toml 遵循的是 RFC 3339 时间格式，只要照着格式写，解析出来会自动转成编程语言的时间类型。 ts = 2021-01-06 07:30:00 ts1 = 2021-01-06 07:30:00.1234 time1 = 07:30:00 得到的结果： { 'ts': datetime.datetime(2021, 1, 6, 7, 30), 'ts1': datetime.datetime(2021, 1, 6, 7, 30, 0, 123000), 'time1': datetime.time(7, 30) } 6. 数组 数组可以是同类型数据，可以换行，也可以嵌套，和python当中列表简直一模一样。但是要注意，尽量保持元素是同类型的数据。 users = [ ['iswy', '男'], ['you', '女'], ] 得到结果： { 'users': [ ['iswy', '男'], ['you', '女'] ] } 7. 哈希表 表有点类似于python中的字典： user = {name='iswy', gender='男'} 得到的结果： { 'user': { 'gender': '男', 'name': 'iswy' } } 这种写在key后面的表叫内联表。还有一种用法，类似于ini格式中的section,用于分组管理，暂且把它叫做外联表。比如上面的例子，可以换一种形式，得到的结果是完全一样的。 [user] gender = '男' name = 'iswy' 表支持嵌套，子表可以缩进也可以不缩进： [user] cat = ['admin', 'normal'] [user.student] name='iswy' age=19 [user.teacher] name='you' age=32 如果你觉得这种风格你不喜欢，也可以换成下面的风格： [user] cat = ['admin', 'normal'] # student student.name='iswy' student.age=19 # teacher teacher.name='you' teacher.age=328 一定要注意，当键包含. 号时，一定要加引号： site.'x.com' = 'http://x.com' 我个人更倾向于子表嵌套的风格，因为这样的表述看起来更加简洁。 表和数组的配套使用 最后我们要考虑的问题是当有多个用户需要配置，我们要使用表数组进行分组呢？ [[user]] [user.student] name='iswy' age=19 [user.teacher] name='you' age=328 [[user]] [user.student] name='iswy2' age=192 [user.teacher] name='you2' age=3282 得到的结果： { 'user': [ { 'student': {'age': 19, 'name': 'iswy'}, 'teacher': {'age': 328, 'name': 'you'} }, { 'student': {'age': 192, 'name': 'iswy2'}, 'teacher': {'age': 3282, 'name': 'you2'} } ] } 使用 python 解析 # 安装导入 import toml with open('demo.toml', encoding='utf-8') as f: data = toml.loads(f.read()) https://github.com/toml-lang/toml/wiki#projects-using-toml ↩︎ ","link":"https://yuz.one/toml-pei-zhi-wen-jian-jian-ming-jiao-cheng/"},{"title":"使用 python 和 selenium 做浏览器兼容测试","content":"在进行web端测试的时候，为了保证网站能在不同的浏览器都有一个良好的表现，我们通常会进行浏览器的兼容测试。浏览器兼容测试的工具非常非常多，比如说大名鼎鼎的 browserling。但是在自动化测试中如何实现浏览器的兼容测试，却没有太多的参考教程，绝大多数的教程都是介绍几个selenium的API，然后就让你自己去拓展，丝毫没有提到通过不同的浏览器运行自动化测试代码的问题。 那么，同一套自动化测试的代码，能不能通过简单的配置，就能启动不同的浏览器分别进行测试呢？我写了几个简单的demo，证实通过一些简单的配置是可以做到浏览器兼容测试的，下面我把具体的过程分享出来。 1. 测试 首先我们需要选定一门编程语言和测试框架。我们就使用Python语言的pytest进行测试，然后使用selenium这个工具去控制浏览器的运行。因为每一个测试用例，我们都需要开启和关闭浏览器，所以开关浏览器的动作可以设置成前置条件（Setup）和后置清理（Teardown），在pytest的这个框架当中，我们使用夹具(fixture)实现浏览器的开关。 # content of conftest.py from selenium import webdriver @pytest.fixture() def browser(): driver = webdriver.Chrome() yield driver driver.quit() 在一个 conftest.py 的文件当中，我们定义一个browser夹具。夹具在本质上来说是一个函数，我们只需要在这个函数名上面加一个装饰器，声明这是一个夹具就可以了。在函数当中，通过 yield 返回浏览器对象，业务的之前的就是前置条件，必要的之后的就是后置清理。 在这个例子当中，yield之前启动一个浏览器，yield之后关掉浏览器。 注意：夹具放到conftest.py这个文件当中，换成其他的文件名是不可以的。 准备好夹具以后，开始编写测试用例。为了方便说明，在测试用例当中，我们只做一件事情，就是打开一个网页。 def test_demo(browser): browser.get(&quot;http://www.baidu.com&quot;) 测试用例是一个以test_开头的函数，这个函数的参数就是我们前面定义好的测试夹具。在执行测试用例函数之前, 程序会先调用测试夹具得到一个浏览器，在测试用例函数执行之后，测试夹具会把浏览器关掉。 现在我们可以直接在文件下通过pytest命令运行测试用例，此时你可以看到一个谷歌浏览器打开并访问了页面。 2. 参数化实现兼容测试 但是现在这个测试夹具不能满足要求，因为它只初始化了一个chrome浏览器，并不能动态的改成其他浏览器。而测试夹具函数当中，我们是不能随意传参数的。但是要实现浏览器的兼容测试，必须每次运行browser测试夹具时动态传递浏览器名称。 实现的第一种方式是通过夹具的参数化。 实现了夹具参数化以后，每次程序先会用其中的一个参数运行所有的测试用例，再换成其他的参数运行用例。 from selenium import webdriver browsers = { &quot;firefox&quot;: webdriver.Firefox, &quot;chrome&quot;: webdriver.Chrome, } @pytest.fixture(params=browsers.keys()) def browser(request): browser_name = request.param driver = browsers.get(browser_name)() yield driver driver.quit() 在这里例子中，我们先把浏览器的名称和要调用的webdriver对象绑定在一起，存在browsers这个字典当中。 然后通过params参数获取broswer.keys(), 也就是所有可以使用的浏览器的名称。当程序运行以后，会自动先使用firefox名称，启动火狐浏览器运行测试用例，再换成chrome浏览器运行用例。如果还有更多的浏览器需要测试兼容性，只需要把他们添加browsers当中。 3. 命令行指定浏览器 在上面的例子中，所有的浏览器都被提前配置到 browsers 变量当中，在运行自动化测试脚本后，所有的浏览器都会依次执行。但是有时候我们并不想这么干。我们就想指定浏览器去跑，又不想频繁修改代码，最省心的方式就是配置一个命令行参数。 pytest要自定义命令行参数非常的简单，只需要在pytest_addoption这个钩子函数中添加命令行参数就可以， 这个钩子函数会收集所有的选项，把值保存到config当中。现在我们给 pytest 自定义一个--browser的命令行参数： def pytest_addoption(parser): parser.addoption( &quot;--browser&quot;, action=&quot;store&quot;, metavar=&quot;browsername&quot;, default=None, help=&quot;config the browser to run&quot;, ) 配置好命令行参数以后，就可以在运行pytest的时候指定哪个浏览器运行了： pytest --browser=chrome 但是现在如果直接运行的话，程序是无法根据你的参数去运行对应的浏览器的。还要改写browser测试夹具，从config当中获取浏览器名称： browsers = { &quot;firefox&quot;: webdriver.Firefox, &quot;chrome&quot;: webdriver.Chrome, } @pytest.fixture() def browser(pytestconfig): browser_name = pytestconfig.getoption('browser') if browser_name not in browsers: raise ValueError(f&quot;browser {browser_name} not supported&quot;) driver = browsers.get(browser_name)() yield driver driver.quit() pytestconfig是pytest自带的测试夹具，可以作为参数放到其他的家具当中，它的作用是获取所有的配置信息。当通过命令行输入浏览器名称以后，就被保存到了pytestconfig这个夹具当中，我们要做的就是通过pytestconfig.getoption(&quot;browser&quot;) 获取broswser这个命令行参数的值，然后去调用对应的浏览器。 文献 https://www.infoq.cn/article/lgrzzui5ee3sne2ntvjw ","link":"https://yuz.one/shi-yong-python-he-selenium-zuo-liu-lan-qi-jian-rong-ce-shi/"},{"title":"配置文件，首选 YAML 和 TOML","content":"1. 配置文件是什么？ 配置文件是用于配置计算机程序的参数和初始化设置的文件。如果没有这些配置，程序可能无法执行。 比如现在你要开发一款 app, 当部署这款 app 时，你需要配置它的 host 地址、数据库地址、数据库名称，这些都可以作为配置项写入配置文件。当项目上线，需要换一个环境运行时，只需要修改配置文件，不需要去代码当中到处查找。 配置文件通常是 key/value 的形式存在，任何支持解析 key/value 形式的文件都是可以作为配置文件的。 现在主流的配置文件格式非常多，比如： Linux 系统中的 .bashrc YAML TOML JSON XML INI 这些都是常用的配置文件格式。接下来，我们来看看用得最多的几种配置文件怎么编写，又是如何通过 python 语言解析的。 2. yaml # default host: &quot;http://www.iswy.com&quot; # 数据库 db: host: &quot;http://www.iswydb.com&quot; port: 3306 name: &quot;py&quot; # 账号 users: - name: &quot;iswy&quot; password: &quot;123456&quot; - name: &quot;iswy_wang&quot; password: &quot;666666&quot; YAML 是目前最推荐的配置文件格式。优秀的配置文件标准它几乎都有： 容易阅读和修改，支持注释。 支持丰富的数据类型。 不同格式的明确表达。 yaml 使用时需要注意： yaml 强制缩进。虽然不规定具体缩进几个空格，但是同一级的内容要保持相同的缩进。 冒号后面一定要加空格， 否则无法解析。 python 解析 yaml 可以使用 pyyaml 库，操作和标准的文件操作非常类似: import yaml with open('api.yml', encoding='utf-8') as f: data = yaml.load(f, Loader=yaml.SafeLoader) 得到的 data 就是解析后的数据，在 python 当中，它是一个嵌套的字典： { 'db': { 'host': 'http://www.iswydb.com', 'name': 'py', 'port': 3306 }, 'host': 'http://www.iswy.com', 'users': [ {'name': 'iswy', 'password': '123456'}, {'name': 'iswy_a', 'password': '666666'} ] } 想获取某一项配置，再通过字典的操作获取： db_host = data['db']['host'] 3. ini [default] host=http://www.iswy.com [db] host=&quot;http://www.iswydb.com&quot; port=3306 name=&quot;py&quot; ini 格式是用得非常多的配置文件格式，有大量的项目都使用 ini 编写配置文件，它比较适合配置项的数据类型只是简单的字符串、数字的情况，如果涉及数组和 key/value 的嵌套，会比较吃力。 ini 格式有几个概念需要了解。用 [] 的叫做 section, 用来对配置项进行分组， 下面的 port 和 name 叫做 option。 如果想获取某一个 option，必须先要获取 section。 通过 python解析 ini： from configparser import ConfigParser parser = ConfigParser() parser.read(&quot;api.ini&quot;, encoding=&quot;utf-8&quot;) host = parser.get(&quot;default&quot;, &quot;host&quot;) db_host = parser.get(&quot;db&quot;, &quot;host&quot;) ini 配置格式有几个注意点： section 无法嵌套， 嵌套后的效果和没有嵌套是一样的。 [default] [db] host=http://www.iswydb.com 获取这个 host 的方式不会发生任何变化，default 并不是 db 的父级。 字符串的表示不要加引号，否则引号也会被解析出来。 [db] host = &quot;http://www.iswydb.com&quot; host2 = http://www.iswydb.com 得到的结果： &quot;http://www.iswydb.com&quot; http://www.iswydb.com = 可以用空格，也可以不用。 4. json { &quot;db&quot;: { &quot;host&quot;: &quot;http://www.db.com&quot;, &quot;port&quot;: 3306 }, &quot;host&quot;: &quot;http://www.iswy.com&quot; } json 在配置文件中的使用频率是上面提到的格式中最低的，原因有几个： 不支持注释， 花括号太多，影响可读性。 通过 python 解析 json 文件： import json with open('api.json', encoding='utf-8') as f: data = json.loads(f.read()) 5. toml host = 'http://www.iswy.com' # 数据库 [db] host = &quot;http://www.iswydb.com&quot; port = 3306 name = &quot;py&quot; # 账号 users = [ {name = 'iswy', password = '123456'}, {name = 'iswy', password = '666666'} ] TOML 结合了 ini 和 yaml 的优点： TOML 的写法和 ini 几乎一致，切换成本为 0 ； 支持所有的 YAML 数据类型，甚至支持时间格式； 支持像 ini 的 section 分组，只是在 TOML 中，它叫做 table; 解析像 YAML 那样简单。 在 python 中解析 TOML 先安装: pip install toml 操作和普通文件的方式非常相似： import toml with open('api.toml', encoding='utf-8') as f: data = toml.loads(f.read()) TOML 的写法非常灵活，后面再出教程。 6. 什么样的数据适合放在配置文件里 配置文件的作用主要是给即将运行的程序提供初始值，凡是在环境发生改变时需要修改的选项就可以设置成配置项。比如上面的域名 host 和数据库设置。 当需要把程序部署到另外的环境，域名和数据库都有可能发生变化，此时可以设置成配置项。 什么样的数据不适合放在配置文件呢？ 每次运行程序都需要检查的，最好不要放在配置文件中，而是通过编程语言进行设置，比如某个依赖文件的路径。 7. 什么要的配置文件格式是好格式 容易阅读和修改、最好支持注释。 所以 json 不是一种好的格式。 易于解析，支持多数据类型。 INI 和 xml 不合适。 不同格式用不同的表达。 YAML 和 TOML 做得非常好。 用配置文件，选 YAML 和 TOML。 参考文献 https://jhall.io/posts/best-config-file-formats/ ","link":"https://yuz.one/pei-zhi-wen-jian-shou-xuan-yaml-he-toml/"},{"title":"python单元测试框架 pytest 入门","content":"1、引言 我有一个朋友是做Python自动化测试的。前几天他告诉我去参加一个大厂面试被刷了。 我问他是有没有总结被刷下来的原因。他说面试官问了一些 pytest 单元测试框架相关的知识，包括什么插件系统和用力筛选。但是他所在的公司用的技术是基于 unittest 的,没有用过 pytest。 我跟他说你可以和技术面试官说明，在实际过程当中你没有使用过 pytest，但是你可以后面再学。这哥们说：我就是这样跟面试官说的，但是面试官告诉我 pytest 现在已经是行业里面的主流，还在坚持用 unittest 说明我的技术已经过时了，没有跟上现在测试领域的发展。 实际上他在面试之前已经了解过 pytest 的一些基础用法，但是网上的一些资料，都是停留在用法和一些知识点的讲解，没有深入到 pytest 内部运行和一些高级特性。所以被问到的时候，自己临时抱佛脚的一些知识都没有用上。 后面我给这位朋友补习了一些关于Python的高级特性。现在我连同基础部分的内容一起贴出来，希望对Python自动化测试的一些朋友有所帮助。 2、为什么用单元测试框架？ 首先我要说明一下什么是单元测试框架? unittest 和 pytest 都是单元测试框架。单元测试指的是在编程过程当中形成的对函数或者是类下面的方法进行测试的一个过程。 在不使用任何框架的前提下，其实也是可以进行单元测试的。比如我们可以通过 if 判断 、异常处理或者是其他的流程控制来表示测试是否通过。 def add(a, b): return a + b def test_add(): ret = add(3, 4) if ret == 7: print(&quot;add 函数的测试通过&quot;) else: print(&quot;add 函数的测试失败&quot;) 如果要运行这个用例，需要手工调用 test_add 这个函数： test_add() 接下来，使用 python 运行这个文件，就能得到测试结果： python test_add.py 虽然说上面我们通过 if 判断，对一个函数进行了测试，而且得到了测试结果，但是流程是比较复杂的： 首先我们需要人工去判断结果， 第2我们需要通过 Python去运行模块。 第3，我们还需要显性的去调用 test_add 这个函数。 这还只是在我们只测试了一个函数的情况下，当需要测试的函数或者类越来越多的时候，这个过程会越来越复杂。 而使用单元测试框架，可以极大的简化我们对单元测试的过程，使用单元测试框架以后，框架会帮我们自动去收集用例、运行用例、生成报告。 3、pytest 的基础使用 上面的测试代码使用 pytest 编写，可以这样写。 def add(a, b): return a + b def test_add(): assert 7 == add(3,4) 写完测试用例以后，我们只需要在目录下输入pytest 指令，就可以自动运行用例，而且呢结果会直接显示在命令行的下方。 上面讲的是单元测试过程，也就是说对某个函数或者是类下面的方法进行测试，有的人可能会不理解。在实际工作过程当中很少进行单元测试啊，测试人员做的更多的是接口测试，UI测试，pytest 怎么用呢？ 实际上不管是接口测试还是UI测试，都是可以使用 pytest。当你进行接口测试的时候，你只需要把访问接口的过程封装成一个Python函数。 def visit_api(): print(&quot;访问接口,得到结果...&quot;) return response def test_api(): assert expected_response == visit_api() 当你进行 web测试的时候，你只需要操作浏览器的过程封装成一个函数？ def browser_method(): print(&quot;点点点&quot;) return ui_response def test_web(): assert expected_response == browser_method() 在这种情况下。接口访问和web操作都是以函数形式存在的，我们直接去测试这个 Python 函数，也是一个单元测试的过程。 因为 pytest 是一个第三方的框架，所以我们先要安装。安装方式非常简单，只需要通过 pip 这个包管理工具安装就可以了。 pip install -U pytest 安装完成以后，我们可以向使用上面的那个例子一样： 第1步：定义一个测试函数，这个测试函数通常会调用被测函数。 第2步：使用assert断言，assert 后面可以跟任意的 Python 条件表达式。 assert 4 &lt; 5 assert &quot;yuze&quot; in &quot;yuze wang&quot; assert isinstance(6, int) 测试用例函数有 2 个注意事项： 函数名称以test_开头； 保存测试用例的文件以test_*.py 的形式或者 *_test.py 的形式。 例行用了以后呢，在命令行当中会显示4个部分的内容: 第1个部分，测试用例和通过的结果， 第2个部分，失败用例回溯信息， 第3个部分，输出捕获信息， 第4个部分，总结信息。 在拍test当中通过的测试用例，不会有特别详细的结果，但是这是失败的测试用例默认会有非常详细的结果，而且会帮你捕获错误原因。 4、测试夹具（Fixture）是什么？ 在测试过程当中，有时你需要提前给你的测试用例去准备一个运行环境。这个测试环境通常来说被称为测试夹具（Fixture），又被称为固定装置、测试固件等。 当你要测试一个电器的时候，你需要提供不同的输入电压电流的环境， 当你测试一台电脑网络的时候，必须要提供网络环境， 当你要测试一个手机游戏能否被安装时，你需要提供一台手机环境， 当你要测试一个软件能否登录的时候，你需要准备用户名和密码这样的用户环境， 当你要测试一个数据库能否操作的时候，需要提供数据库的连接环境。 现在我们来举一个夹具的例子，我们需要测试一个注册的函数。这个注册函数提供两个参数，第1个参数是手机号，第2个参数是密码。注册函数的逻辑就是对手机号码和密码进行校验，如果通过校验表示注册成功，如果不通过表示注册失败。 def is_mobile(number: str): if re.search(r&quot;^1[3-9][0-9]{9}$&quot;, number): return True return False def register(mobile, password): if is_mobile(mobile) and len(password) &gt;= 6: return &quot;success&quot; return &quot;fail&quot; def test_register(): assert &quot;success&quot; == register(&quot;13177778888&quot;, &quot;123456&quot;) 这个测试用例并没有什么问题，但是它存在优化的空间。一个优化的空间是每个手机号码都是我们手工生成的，当需要编写多组数据测试时，会有一点费时间。现在我们可以编写一个函数，自动生成一个手机号码，当我有多组数据需要测试的时候，我只需要重复调用生成手机号码的函数，就可以获取测试数据。这个生成手机号码的函数呢，就是一个夹具。 def gen_a_mobile(): &quot;&quot;&quot;随机生成 13 开头的手机号码。&quot;&quot;&quot; random_num = &quot;&quot;.join([str(random.randint(1,9)) for i in range(9)]) return &quot;&quot;.join([&quot;13&quot;, random_num]) pytest 提供了一种叫做依赖注入的机制，当一个函数被声明为夹具的时候，可以在测试函数中传入这个夹具的名称，pytest会自动调用它。 import random import pytest @pytest.fixture def gen_a_mobile(): &quot;&quot;&quot;随机生成 13 开头的手机号码。&quot;&quot;&quot; random_num = &quot;&quot;.join([str(random.randint(1,9)) for i in range(9)]) return &quot;&quot;.join([&quot;13&quot;, random_num]) def test_register(gen_a_mobile): assert &quot;success&quot; == register(gen_a_mobile, &quot;123456&quot;) pytest 当中的夹具系统非常非常的灵活，后面如果有时间的我专门写文章跟大家讲解夹具系统。 5、数据驱动和参数化 现在我们编写的函数和测试用例是1对1的关系，也就是说，当你想测试某个功能场景的时候，你必须要去编写一个对应的测试函数。当测试的场景越来越多，测试数据越来越复杂的情况下，需要编写更多的测心率函数，而这些函数的逻辑基本上是重复的。 在 pytest 当中可以使用参数化这种测试手段，简化编写用例函数的过程。我们并不需要为每一组测试数据单独去编写一个测试函数，而是采取多种数据共用一个函数的方式。如果测试操作几乎一致，可以重复使用这一个函数进行测试。 import pytest cases = [ (1, 2, 3), (&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;), (1, &quot;world&quot;, &quot;1world&quot;) ] @pytest.mark.parametrize(&quot;a,b,expected&quot;, cases) def test_add(a, b, expected): assert expected == add(a, b) 在这个例子当中，cases这个变量存储了三组测试用例的数据，每一组测试数据用一个元组表示，元组的第1个元素代表a，第2个元素代表B，第3个元素代表预期结果。 @pytest.mark.parametrize(&quot;a,b,expected&quot;, cases) 这一行代码的意思是说，每一次从cases变量当中取出一组测试数据。分别用a、b 、expected 三个变量接收，然后我们把这三个变量名作为函数的参数传递到 test_add 当中，就实现了参数化的过程。 当使用这一种参数化的手段进行测试的时候，测试数据和测试函数是多对一的关系，对于多组测试数据，我们只需要去编写一个测试函数，极大的提升了代码编写效率。 6、测试报告和插件 最后我们来说一下测试报告。pytest 当中的测试报告，通常是以插件的形式生成的，如果你想生成一个html格式的测试报告，可以先安装 pytest-html 这个插件。 pip install pytest-html 接下来你需要在运行用例的时候，在 pytest 命令后面加上 --html=&lt;测试报告名称&gt;.html pytest --html=report.html 当运行完用例以后，你可以在当前目录下找到一个 report.html 的文件，打开就可以查看测试报告了。 pytest 之所以成为主流，有很多的原因，其中最重要的一个原因是因为其强大的插件系统。任何一个程序员，只要遵循一些简单的规范，就可以轻易的编写插件。后面我们再跟大家深入去研究 pytest 当中的夹具系统，插件系统和钩子函数这些特性。 ","link":"https://yuz.one/pytest-gettting-started/"}]}